# coding:utf-8

import os
import threading
import socket


client_hex_ver = [0x15,0xF4,0xA1,0xED,0xA9,0xF9,0xE4,0xBE,0xA0,0xA4,0xF9,0x55,0x25,0x24,0x69,0x3B,0x48,0x12,0x64,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x25,0x29,0x24,0x30,0x24,0xFC,0x5C,0x0E]
client_hex_crt = [0x15,0xF4,0xA1,0xED,0xA9,0xF9,0xE4,0xBE,0xA0,0xA4,0xF9,0x55,0x25,0x24,0x69,0x3B,0x48,0x12,0x64,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x25,0x29,0x24,0x30,0x84,0xFD,0x5C,0x0E]
server_hex = [0x15,0xF4,0xA1,0xED,0xA9,0xF9,0xE4,0xBE,0xA0,0xA4,0xF9,0x55,0x25,0xC4,0x69,0x3B,0x48,0x12,0x64,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x20,0x29,0x24,0x30,0x24,0x24,0x69,0x3B,0x25,0x29,0x24,0x30,0x24,0xFC,0x5C,0x0E]
heartHit_hex = [0x15,0xF4,0xA1,0xED,0xA1,0xF9,0xE4,0xBE,0xA5,0xB4,0xF9,0x05,0x11,0x11,0x5C,0x0E]

client_str_ver = ''.join([chr(h) for h in client_hex_ver])
client_str_crt = ''.join([chr(h) for h in client_hex_crt])
server_str = ''.join([chr(h) for h in server_hex])
heartHit_str = ''.join([chr(h) for h in heartHit_hex])


class Httpd():

    def __init__(self):
        self.srv_ip = '0.0.0.0'   # 服务器监听IP
        self.srv_port = 8080   # 服务器监听端口s

    def load(self):
        """ 启动监听 """
        self.srv = socket.socket(
            socket.AF_INET, socket.SOCK_STREAM)  # 实例化tcp类型的socket
        self.srv.bind((self.srv_ip, self.srv_port))  # 绑定端口和IP
        self.srv.listen(1)  # 启动监听
        print("Httpd server is listening: {ip}:{port}".format(
            ip=self.srv_ip, port=self.srv_port))   # 打印服务器监听信息

    def run(self):
        """ 运行处理方法，接收客户端的请求 """
        self.load()     # 启动监听
        while True:     # 使主线程一直处于监听状态
            clt, addr = self.srv.accept()    # 接收客户端的请求，返回客户端socket对象和客户端地址
            print(u"来自客户端请求 {addr}".format(addr=addr))    # 打印客户端信息
            # 新开一个线程处理客户端请求
            t = threading.Thread(target=self.request_handle, args=(clt,addr))
            t.setDaemon(True)
            t.start()  # 启动线程处理请求
            print(u"线程启动完毕，继续监听...")

    def request_handle(self, clt, addr):
        """ 接收数据，处理请求 """
        recv_data = ''
        recv_dataTmp = ''
        try:
            while True:
                recv_data = clt.recv(512)
                
                if(recv_data==client_str_ver):      #认证请求
                    clt.send(server_str)
                # if(recv_data==client_str_crt):       #　新建请求　
                #     clt.send(server_str)
                if(recv_data==heartHit_str):        # 心跳请求
                    clt.send(heartHit_str)
                else:
                    clt.send(server_str)    #　未知请求时发送的数据

                # print(recv_data)
                recv_data = ''
        except Exception as e:
            print(u'客户端连接异常: {addr}'.format(addr=addr))
        finally:
            print(u'关闭客户端连接: {addr}'.format(addr=addr))
            clt.close()
        

if __name__ == '__main__':
    srv = Httpd()
    srv.run()